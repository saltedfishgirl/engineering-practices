# 写出好的CL描述

一个CL描述是一个公共记录什么正在取得的变化和为什么 它被做。它将成为我们版本控制历史的永久部分，并且多年来可能会被除审阅者之外的数百人阅读。

未来的开发人员将根据其描述搜索您的CL。未来的某个人可能正在寻找你的改变，因为它的相关性有微弱的记忆，但没有方便的细节。如果所有重要信息都在代码而不是描述中，那么他们找到你的CL会更加困难。


## 第一行{#firstline}
- 正在做什么的简短摘要。
- 完整的句子，写成好像是订单。
- 跟着空行。

CL描述的第一行应该是对CL正在做的具体工作的简短总结，后面是一个空行。这是大多数未来的代码搜索者在浏览一段代码的版本控制历史时会看到的，因此第一行应该足够有信息量，他们不必阅读您的CL或它的整个描述就可以大致了解您的CL实际做了什么。

按照传统，CL描述的第一行是一个完整的句子，就像它是一个顺序（命令句）一样。例如，说“Delete the FizzBuzz RPC and replace it with the new system.”而不是“Deleting the FizzBuzz RPC and replacing it with the new system.”。不过，您不必将描述的其余部分作为命令语句编写。


## 正文是信息性的{#informative}
其余的描述应该是信息性的。它可能包括对正在解决的问题的简要描述，以及为什么这是最好的方法。如果这种方法有任何缺点，就应该提到。如果相关，请包括背景信息，如错误号、基准测试结果和指向设计文档的链接。

即使是很小的CLS也值得注意细节。将CL置于上下文中。

## 坏CL描述{#bad}
“Fix bug”是一个不充分的CL描述。什么bug？你做了什么修复它？其他类似的错误描述包括：
- "Fix build."
- "Add patch." 
- "Moving code from A to B."
- "Phase 1."
- "Add convenience functions."
- "kill weird URLs."
其中一些是真实的CL描述。他们的作者可能认为他们提供了有用的信息，但他们并没有达到CL描述的目的。


## 好的CL描述{#good}
以下是一些很好的描述示例。

- 功能变更

rpc:删除rpc服务器消息freelist上的大小限制。

像fizzbuzz这样的服务器有非常大的消息，可以从重用中受益。使空闲列表变大，并添加一个goroutine，该goroutine随着时间的推移缓慢释放空闲列表条目，以便空闲服务器最终释放所有空闲列表条目。

前几个词描述了cl实际做什么。其余的描述将讨论正在解决的问题，为什么这是一个好的解决方案，以及关于具体实现的更多信息。

- 重构

使用TimeKeeper构造任务以使用其TimeStr和Now方法。

向任务中添加now方法，这样就可以删除borglet（）getter方法（oomcandidate只使用它来调用borglet的now方法）。这将替换borglet上委托给计时器的方法。

现在允许任务供应是消除对Borglet依赖的一个步骤。最终，依赖于从任务中获得“现在”的协作者应该被更改为直接使用计时器，但这是一种适应于在小步骤中重构的方法。

继续重构borglet层次结构的长期目标。

第一行描述了CL做了什么，以及它是如何与过去发生变化的。其余的描述将讨论具体的实现、CL的上下文、解决方案不理想以及未来可能的方向。这也解释了为什么要做出这种改变。

- 需要上下文的小CL

为status.py创建python3生成规则。

这允许已经在python3中使用此规则的用户依赖于原始状态构建规则旁边的规则，而不是自己树中的某个位置。它鼓励新用户尽可能使用python3，而不是python2，并大大简化了当前正在使用的一些自动构建文件重构工具。

第一句描述了实际正在做的事情。描述的其余部分解释了为什么要进行更改，并为审阅者提供了很多上下文。
## 在提交CL之前查看说明
CL在审核期间可能会发生重大变化。在提交CL之前检查CL描述是值得的，以确保描述仍然反映了CL的作用。

下一篇：[小型CL]()
